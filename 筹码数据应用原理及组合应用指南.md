# 筹码数据应用原理及组合应用指南

## 1. 筹码数据概述

### 1.1 数据来源
- **筹码分布数据接口**：`cyq_chips` (Tushare)
- **筹码及胜率数据接口**：`cyq_perf` (Tushare)
- **更新频率**：每日17-18点更新
- **数据范围**：2018年至今

### 1.2 两种数据的特点

#### 1.2.1 筹码分布数据 (cyq_chips)
- **数据粒度**：细粒度，提供每个具体价格位的筹码占比
- **数据量**：每只股票每天可能有数百条记录
- **核心字段**：ts_code, trade_date, price, percent
- **应用特点**：适合精确分析特定价格区间和支撑阻力位

#### 1.2.2 筹码及胜率数据 (cyq_perf)
- **数据粒度**：粗粒度，提供分位成本价格和整体胜率
- **数据量**：每只股票每天1条记录
- **核心字段**：各分位成本、加权平均成本、胜率
- **应用特点**：适合宏观分析和风险评估

## 2. 筹码分布数据应用原理

### 2.1 基本概念
筹码分布是指股票在不同价格区间的持仓成本分布情况，反映了市场参与者在各个价格位的持仓比例。

### 2.2 支撑阻力位识别
**原理**：筹码密集的价格位通常形成重要的支撑位或阻力位

**应用方法**：
```sql
-- 查找筹码密集的价格位
SELECT price, percent 
FROM cyq_chips 
WHERE ts_code = '000001.SZ' AND trade_date = '20241201'
ORDER BY percent DESC
LIMIT 10
```

**判断标准**：
- 占比>5%：重要支撑/阻力位
- 占比>10%：强支撑/阻力位
- 占比>15%：极强支撑/阻力位

### 2.3 获利盘与套牢盘分析
**计算方法**：
```sql
-- 计算获利盘和套牢盘比例
SELECT 
    SUM(CASE WHEN price < current_price THEN percent ELSE 0 END) as profit_ratio,
    SUM(CASE WHEN price > current_price THEN percent ELSE 0 END) as loss_ratio
FROM cyq_chips 
WHERE ts_code = '000001.SZ' AND trade_date = '20241201'
```

**市场含义**：
- **高获利盘**：面临获利回吐压力，上涨阻力较大
- **高套牢盘**：面临解套压力，下跌阻力较大
- **平衡状态**：相对安全，波动可能较小

## 3. 筹码及胜率数据应用原理

### 3.1 分位成本分析
**分位成本含义**：
```python
cost_5pct   # 最便宜的5%筹码成本
cost_15pct  # 最便宜的15%筹码成本  
cost_50pct  # 中位数成本，代表平均成本
cost_85pct  # 最贵的15%筹码成本
cost_95pct  # 最贵的5%筹码成本
```

**成本分布应用**：
- **支撑位识别**：
  - 5分位成本：强支撑位
  - 15分位成本：重要支撑位
  - 50分位成本：平均成本支撑位
- **阻力位识别**：
  - 85分位成本：重要阻力位
  - 95分位成本：强阻力位

### 3.2 胜率指标分析
**胜率计算原理**：
```python
winner_rate = 当前价格高于历史成本的筹码比例
```

**胜率等级划分**：
- **高胜率** (>70%)：获利盘较多，面临获利回吐压力
- **中胜率** (30%-70%)：相对平衡，风险适中
- **低胜率** (<30%)：套牢盘较多，面临解套压力

## 4. 组合应用策略

### 4.1 支撑阻力位精确识别

```python
def identify_support_resistance_combined(ts_code, trade_date):
    """
    结合两种数据精确识别支撑阻力位
    """
    # 从筹码分布数据获取精确价格位
    chips_query = f"""
    SELECT price, percent 
    FROM cyq_chips 
    WHERE ts_code = '{ts_code}' AND trade_date = '{trade_date}'
    AND percent > 3  -- 筹码占比超过3%
    ORDER BY percent DESC
    """
    
    # 从筹码及胜率数据获取分位成本
    perf_query = f"""
    SELECT cost_5pct, cost_15pct, cost_50pct, cost_85pct, cost_95pct
    FROM cyq_perf 
    WHERE ts_code = '{ts_code}' AND trade_date = '{trade_date}'
    """
    
    # 结合分析形成多层次的支撑阻力体系
    return combined_analysis
```

### 4.2 买入时机优化

```python
def optimize_buy_timing(ts_code, current_price):
    """
    结合两种数据优化买入时机
    """
    # 获取两种数据
    chips_data = get_chips_distribution(ts_code)
    perf_data = get_perf_data(ts_code)
    
    buy_signals = []
    
    # 信号1：精确支撑位 + 低胜率
    if (current_price接近chips_data中的高占比价格位 and 
        perf_data['winner_rate'] < 0.3):
        buy_signals.append("精确支撑位+低胜率")
    
    # 信号2：分位成本支撑 + 适中胜率
    if (current_price接近perf_data['cost_15pct'] and 
        0.3 < perf_data['winner_rate'] < 0.6):
        buy_signals.append("成本支撑+适中胜率")
    
    # 信号3：筹码密集区 + 成本支撑确认
    if (chips_data中有高占比价格位接近perf_data['cost_50pct']):
        buy_signals.append("筹码密集+成本支撑")
    
    return buy_signals
```

### 4.3 卖出策略优化

```python
def optimize_sell_timing(ts_code, current_price):
    """
    结合两种数据优化卖出时机
    """
    chips_data = get_chips_distribution(ts_code)
    perf_data = get_perf_data(ts_code)
    
    sell_signals = []
    
    # 信号1：高胜率 + 接近阻力位
    if (perf_data['winner_rate'] > 0.7 and 
        current_price接近perf_data['cost_85pct']):
        sell_signals.append("高胜率+成本阻力")
    
    # 信号2：筹码密集阻力位
    if (chips_data中有高占比价格位接近current_price and
        current_price > perf_data['cost_50pct']):
        sell_signals.append("筹码密集阻力位")
    
    return sell_signals
```

## 5. 风险控制机制

### 5.1 组合风险控制

```python
def enhanced_risk_control(ts_code, current_price):
    """
    结合两种数据增强风险控制
    """
    chips_data = get_chips_distribution(ts_code)
    perf_data = get_perf_data(ts_code)
    
    risk_level = "低风险"
    
    # 风险因素1：高胜率 + 筹码密集区
    if (perf_data['winner_rate'] > 0.7 and 
        chips_data中有高占比价格位接近current_price):
        risk_level = "高风险"
    
    # 风险因素2：成本分布范围大 + 筹码分散
    cost_range = perf_data['cost_95pct'] - perf_data['cost_5pct']
    if cost_range / perf_data['cost_50pct'] > 0.5:
        risk_level = "中高风险"
    
    # 风险因素3：低胜率 + 远离成本支撑
    if (perf_data['winner_rate'] < 0.3 and 
        current_price < perf_data['cost_15pct']):
        risk_level = "中风险"
    
    return risk_level
```

### 5.2 止损设置策略

```python
def set_stop_loss_combined(ts_code, entry_price):
    """
    基于组合数据设置止损位
    """
    chips_data = get_chips_distribution(ts_code)
    perf_data = get_perf_data(ts_code)
    
    # 方法1：基于筹码分布的重要支撑位
    strong_support_chips = get_strong_support_from_chips(chips_data)
    
    # 方法2：基于分位成本的支撑位
    strong_support_perf = perf_data['cost_5pct'] * 0.98
    
    # 选择更保守的止损位
    stop_loss = min(strong_support_chips, strong_support_perf)
    
    return stop_loss
```

## 6. 量化指标构建

### 6.1 筹码分布指标

```python
# 筹码集中度指标
concentration = STDDEV(percent)  # 筹码分布的标准差

# 重要价格位数量指标
key_levels = COUNT(CASE WHEN percent > 5 THEN 1 ELSE 0 END)

# 获利盘比例指标
profit_ratio = SUM(CASE WHEN price < current_price THEN percent ELSE 0 END)
```

### 6.2 筹码及胜率指标

```python
# 成本分布范围
cost_range = cost_95pct - cost_5pct

# 成本集中度
cost_concentration = (cost_85pct - cost_15pct) / cost_50pct

# 当前价格相对50分位成本位置
price_vs_median = (current_price - cost_50pct) / cost_50pct * 100

# 胜率等级
def get_winner_level(winner_rate):
    if winner_rate > 0.7:
        return "高胜率"
    elif winner_rate > 0.3:
        return "中胜率"
    else:
        return "低胜率"
```

### 6.3 组合指标

```python
# 支撑阻力位强度指标
def support_resistance_strength(ts_code):
    """
    结合两种数据计算支撑阻力位强度
    """
    chips_strength = get_chips_based_strength(ts_code)
    perf_strength = get_perf_based_strength(ts_code)
    
    # 加权平均
    combined_strength = chips_strength * 0.6 + perf_strength * 0.4
    
    return combined_strength

# 风险收益比指标
def risk_reward_ratio(ts_code, entry_price, target_price):
    """
    基于组合数据计算风险收益比
    """
    stop_loss = set_stop_loss_combined(ts_code, entry_price)
    risk = entry_price - stop_loss
    reward = target_price - entry_price
    
    # 考虑胜率调整
    perf_data = get_perf_data(ts_code)
    if perf_data['winner_rate'] < 0.3:
        reward_ratio = reward / risk * 1.2  # 低胜率时提高收益预期
    else:
        reward_ratio = reward / risk * 0.8  # 高胜率时降低收益预期
    
    return reward_ratio
```

## 7. 实际应用案例

### 7.1 案例一：精确突破确认

**场景**：股价突破某个价格位

**分析步骤**：
1. **筹码分布数据**：确认该价格位是否有高筹码占比
2. **筹码及胜率数据**：确认该价格位相对于分位成本的位置
3. **组合判断**：
   - 如果价格位筹码占比>5%且接近85分位成本 → 强突破信号
   - 如果价格位筹码占比<2%且远离分位成本 → 假突破可能

### 7.2 案例二：多层次支撑分析

**场景**：股价回调寻找支撑

**分析步骤**：
1. **筹码分布数据**：识别具体的支撑价格位
2. **筹码及胜率数据**：确认支撑位的强度等级
3. **组合应用**：
   - 5分位成本 + 高筹码占比价格位 → 极强支撑
   - 15分位成本 + 中等筹码占比价格位 → 强支撑
   - 50分位成本 + 低筹码占比价格位 → 一般支撑

### 7.3 案例三：风险收益优化

**场景**：评估交易机会的风险收益比

**分析步骤**：
1. **筹码分布数据**：计算目标价格位的筹码分布
2. **筹码及胜率数据**：评估整体市场情绪和成本分布
3. **综合评估**：结合胜率和筹码分布调整风险收益预期

## 8. 策略实施建议

### 8.1 数据获取优化

```python
def get_combined_chips_data(ts_code, trade_date):
    """
    获取组合筹码数据
    """
    # 获取筹码分布数据
    chips_data = get_chips_distribution(ts_code, trade_date)
    
    # 获取筹码及胜率数据
    perf_data = get_perf_data(ts_code, trade_date)
    
    return {
        'chips_distribution': chips_data,
        'perf_summary': perf_data,
        'combined_analysis': analyze_combined_data(chips_data, perf_data)
    }
```

### 8.2 策略实施流程

```python
def combined_trading_strategy(ts_code):
    """
    组合交易策略实施流程
    """
    # 1. 获取组合数据
    data = get_combined_chips_data(ts_code)
    
    # 2. 识别交易机会
    opportunities = identify_opportunities(data)
    
    # 3. 风险评估
    risk_assessment = assess_risk(data)
    
    # 4. 制定交易决策
    decision = make_trading_decision(opportunities, risk_assessment)
    
    # 5. 设置止损止盈
    stop_loss = set_stop_loss_combined(ts_code, decision['entry_price'])
    take_profit = set_take_profit_combined(ts_code, decision['entry_price'])
    
    return {
        'decision': decision,
        'stop_loss': stop_loss,
        'take_profit': take_profit,
        'risk_level': risk_assessment
    }
```

### 8.3 参数优化建议

- **根据个股特性调整**：不同股票的筹码分布特征不同
- **根据市场环境调整**：牛市和熊市的策略参数应有所区别
- **定期评估和优化**：根据实际表现调整参数设置

## 9. 总结

筹码数据的组合应用提供了：

### 9.1 信息优势
- **精确性**：筹码分布数据提供精确的价格位信息
- **宏观性**：筹码及胜率数据提供宏观的成本分布和情绪指标
- **互补性**：两种数据相互补充，形成完整分析体系

### 9.2 应用价值
- **支撑阻力位识别**：多层次、精确的支撑阻力位分析
- **买卖时机优化**：基于多重信号的买卖决策
- **风险控制增强**：从多个维度评估和控制风险
- **策略可靠性提升**：双重确认提高策略可信度

### 9.3 实施要点
- **数据质量保证**：确保数据的及时性和准确性
- **参数动态调整**：根据市场环境和个人偏好调整参数
- **风险控制优先**：始终将风险控制放在首位
- **持续学习优化**：根据实际表现不断优化策略

通过这种组合应用，可以充分利用两种筹码数据的优势，形成更加完善、可靠和实用的交易策略体系。 